# 一、UML图

## 1、类图

类图包含三部分：名称部分（Name）、属性部分（Attribute）、操作部分（Operation）

其中属性的表现形式是**[可见性] 属性名:类型 [=默认值]**。操作的表现形式是：**[可见性] 名称（参数列表）[：返回类型]**。

![image-20201222183108769](https://cdn.jsdelivr.net/gh/sphshenpeihong/javaPic/img/20201222183109.png)



## 1.1、类图的基础属性

![image-20201222183120920](https://cdn.jsdelivr.net/gh/sphshenpeihong/javaPic/img/20201222183122.png)



## 1.2、类之间关系

在UML类图中，常见的有以下几种关系: 

泛化（Generalization）：带空心三角箭头的实线来表示，箭头由子类指向父类

实现（Realization）：带空心的三角箭头的虚线来表示，箭头从实现类指向接口

关联（Association)：分为双向关联和单向关联，其中，双向关联可以用带两个箭头或者没有箭头的实线来表示，单向关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类，还可以再关联线的两端标注角色名，补充说明它们的角色。

聚合（Aggregation），用带空心菱形的实线表示，菱形指向整体

组合(Composition)：用带实心菱形的实线来表示，菱形指向整体。

依赖(Dependency)：使用带箭头的虚线表示，箭头从使用类指向被依赖的类

下图为类之间的关系在UML中的图形表达式：

![image-20201222183137498](https://cdn.jsdelivr.net/gh/sphshenpeihong/javaPic/img/20201222183138.png)



//。。。。。。。。。。。。。

详细：https://www.cnblogs.com/liujiarui/p/12289537.html



#### 1.2.1、泛化

泛化(Generalization)表示类与类之间的继承关系，接口与接口之间的继承关系，或类对接口的实现关系



#### 1.2.2、实现



#### 1.2.3、关联



#### 1.2.4、聚合



#### 1.2.5、组合



#### 1.2.6、依赖

类之间的关系有依赖关系，如何判断一个类是否依赖另一个类或者接口呢，看该类是否有定义其它类的成员变量或者是定义的方法的形参使用到了其它类或接口，那么需要"注入"才能使用，否则被依赖的对象直接就为空了，空对象就用不了了，强行用的话可能会导致空指针问题。

如果有其它实现类已经实现了接口并且写好了接口定义的功能的话，那么我们可以依赖一个变量或直接创建对象，声明的时候可以采用向上转型(一定要用向上转型成接口，因为我们依赖倒置原则的理念就是面向接口编程，而不是面向实现类编程，如果我们定义了多个类的话，那么就得定义很多个方法，因为你的方法形参随着实现类的增加而增加，但是面向接口不会有这个问题，直接定义一个方法，然后定义成接口类型，那么到时候实现类去实现接口即可)。

所以我们如果需要用到其它实现类的方法的话，可以采用定义成员变量然后采用注入的方式 或者是 直接在当前书写的方法的形参变量声明成该实现类的实现接口的类型。

使用成员变量+注入的方式

- 好处：存放在堆中，该类的所有方法都可以使用该成员变量 （没必要定义成static了，除非一定需要一定共享变量，或者提供的方法是static的）

- 坏处：如果直接定义在方法形参的话，那么是存放在栈中，方法压栈结束的话，那么该局部变量会消失。

使用方法形参的方式

- 好处：存放在栈中，方法结束，方法栈消失。 而且如果同一个接口，但是不同个实现类的话，那么此时向上转型定义成接口就香了
- 坏处：调该方法的时候，需要传递实体类的对象(可向上转型)



